#!/usr/bin/env python
import argparse
import logging
import os
import sys

import requests

sys.path.insert(0, os.path.abspath(os.path.join(__file__, os.pardir, os.pardir)))

from cli.cluster import MMTApi, DEFAULT_MMT_API_PORT
from cli.libs import multithread
from cli.translate import BatchExecutor, InteractiveExecutor


def main():
    parser = argparse.ArgumentParser(description='Simple translation script to query MMT.')

    # Context arguments
    parser.add_argument('--context', metavar='CONTEXT', dest='context',
                        help='A string to be used as translation context')
    parser.add_argument('--context-file', metavar='CONTEXT_FILE', dest='context_file',
                        help='A local file to be used as translation context')
    parser.add_argument('--context-weights', metavar='CONTEXT_WEIGHTS', dest='context_weights',
                        help='A domain-to-score map encoded: <document 1>:<score 1>[,<document N>:<score N>]')

    # NBest list arguments
    parser.add_argument('--nbest', metavar='NBEST', dest='nbest', default=None, type=int,
                        help='The number of nbest to print')
    parser.add_argument('--nbest-file', metavar='NBEST_FILE', dest='nbest_file', default=None,
                        help='The destination file for the NBest, default is stdout')

    # Translation alignments arguments
    parser.add_argument('--alignment', action='store_true', dest='alignment', default=False,
                        help='if set, the alignments will be printed')
    parser.add_argument('--alignment-file', metavar='ALIGNMENT_FILE', dest='alignment_file', default=None,
                        help='The destination file for the alignments, default is stdout')

    # Mixed arguments
    parser.add_argument('-e', '--engine', dest='engine', help='the engine name, \'default\' will be used if absent',
                        default=None)
    parser.add_argument('-p', '--api-port', dest='api_port', metavar='API_PORT',
                        help='the public available REST Api port. (default is {port})'
                        .format(port=DEFAULT_MMT_API_PORT), default=None, type=int)
    parser.add_argument('--no-process', action='store_false', dest='process', default=True,
                        help='if set, the script will skip pre- and post-processing of the text')
    parser.add_argument('--batch', action='store_true', dest='batch', default=False,
                        help='if set, the script will read the whole stdin before send translations to MMT.'
                             'This can be used to execute translation in parallel for a faster translation. ')

    args = parser.parse_args()

    executor = None

    try:
        # Check context arguments
        if (args.context is not None and (args.context_file is not None or args.context_weights is not None)) or \
                (args.context_file is not None and (args.context is not None or args.context_weights is not None)) or \
                (args.context_weights is not None and (args.context_file is not None or args.context is not None)):
            raise CLIArgsException('you can specify only one context option')

        if args.alignment:
            raise CLIArgsException('alignment is not yet supported')

        # Create Api
        api = MMTApi(args.api_port if args.api_port is not None else DEFAULT_MMT_API_PORT)

        executor = BatchExecutor(api, args) if args.batch else InteractiveExecutor(api, args)

        while 1:
            line = sys.stdin.readline()
            if not line:
                break

            executor.execute(line.strip())
        executor.flush()

    except KeyboardInterrupt:
        # exit
        pass
    except CLIArgsException as e:
        msg = 'translate: error: {message}\n'.format(prog=parser.prog, message=e.message)
        parser.print_usage(file=sys.stderr)
        sys.stderr.write(msg)

        return 1
    finally:
        if executor is not None:
            executor.close()

    return 0


if __name__ == '__main__':
    logging.basicConfig(
        format='%(asctime)-15s [%(levelname)s] - %(message)s',
        level=logging.INFO,
        stream=sys.stderr
    )

    exitcode = main()
    exit(exitcode)
