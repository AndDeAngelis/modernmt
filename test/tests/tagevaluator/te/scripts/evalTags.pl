#!/usr/bin/perl

# This scripts computes accuracy on HTML tags in the file generated by
# tercom (*.pra_more)

use Encode qw(encode decode);
use utf8;
$|=1;

exit print "usage: \n\n evalTags.pl TercomPraMoreFile [verbosity (0=default,1,2)]\n\n" if $#ARGV != 0 && $#ARGV != 1;


$pramoreFn=$ARGV[0];
if ($#ARGV == 1) {
    $verbose=$ARGV[1];
    if ($verbose!=0 && $verbose!=1 && $verbose!=2) {
	printf "Wrong verbosity level (%s)\n", $verbose;
	print "usage: \n\n evalTags.pl TercomPraMoreFile [verbosity (0=default,1,2)]\n\n";
	exit(0);
    }
} else {
    $verbose=0;
}
printf "verbose=$verbose\n";

open (FH, "<$pramoreFn") or die "\nUnable to open file '$pramoreFn'";
chop(@in=<FH>);
close(FH);

$init=1;
$TOTtagRefN=0; $TOTcorr=0; $TOTsub=0; $TOTdel=0; $TOTins=0; $TOTshift=0;

for ($i=0; $i<=$#in; $i++) {
    $in[$i]=decode("utf8",$in[$i]); # needed for counting special German chars (ü,ß...) as a single character

    # read data available for the current sentence:

    if ($in[$i]=~/Sentence ID:/) { # start info on this sentence/segment

	if (!$init) { # if this is not the first segment, print scores
		      # of the previous segment and update global counts

	    if ($tagRefN>0) {
		printf "Sentence %9s: tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %05.2f\n",
		$sentId,  $tagRefN, $corr, $sub, $del, $ins, $shift, "%", 100*(1-($corr-$ins)/$tagRefN);
	    } else {
		printf "Sentence %9s: tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %05.2f\n",
		$sentId,  0, 0, 0, 0, 0, 0, "%", 0;
	    }
	    printf "\n" if ($verbose>0);

	    $TOTtagRefN+=$tagRefN; 
	    $TOTcorr+=$corr; 
	    $TOTsub+=$sub; 
	    $TOTdel+=$del; 
	    $TOTins+=$ins; 
	    $TOTshift+=$shift;

	} else {
	    $init=0;
	}

	printf "%s\n", $in[$i] if ($verbose>0);
	$sentId = $in[$i];
	$sentId =~s/Sentence ID:[ \t]+//;
	$tagRefN=0; $corr=0; $sub=0; $del=0; $ins=0; $shift=0;
    } 
    if ($in[$i]=~/^REF:/) { # store ref tokens
	$REF = $in[$i];
	printf "%s\n", encode("utf8",$REF) if ($verbose>0);
	$REF =~s/REF:[ \t]+//; $REF =~s/[ \t]+/ /g; $REF =~s/^ | $//g;
	@ref = split(/ /, $REF);
    } 
    if ($in[$i]=~/^HYP:/) { # store hyp tokens
	$HYP = $in[$i];
	printf "%s\n", encode("utf8",$HYP) if ($verbose>0);
	$HYP =~s/HYP:[ \t]+//; $HYP =~s/[ \t]+/ /g; $HYP =~s/^ | $//g;
	@hyp=split(/ /, $HYP);
    } 
    if ($in[$i]=~/Shift[ \t]+\[([^\]]+)\].*/) { # got a shift
	$tokenShifted=$1;
	printf "tagShifted=>>>%s<<<\n", encode("utf8",$tokenShifted) if (&isTag($tokenShifted)) && ($verbose>0);
	if (&isTag($tokenShifted)) { 
	    $shift++; # count if the shift regards a tag
	    $corr--;  # this match was counted as correct, but indeed
		      # it is not
	}


    }

    if  ($in[$i]=~/TER Score:/) { # last entry of the current segment:
				  # compute the errors on its tags

	for ($j=0; $j<=$#hyp; $j++) {
	    # remove symbols {[,],@} used for indicating shifts in hyp
	    # (they are wrongly removed also in case they are part of
	    # the hypothesis):
	    if (!($hyp[$j] cmp "[") ||
		!($hyp[$j] cmp "]") ||
		!($hyp[$j] cmp "@")) {
		splice(@hyp, $j, 1);
		$j--; # now there is one less token in hyp, then the
		      # token in position $j has to be checked again
	    }
	}
	for ($j=0; $j<=$#ref; $j++) {
	    # in hyp, symbols {[,],@} used for indicating shifts are
	    # removed, but thay are removed also if they are part of
	    # the original hypothesis; in ref, they are removed to be
	    # "aligned" with is done on hyp:
	    if (!($ref[$j] cmp "[") ||
		!($ref[$j] cmp "]") ||
		!($ref[$j] cmp "@")) {
		splice(@ref, $j, 1);
		$j--; # now there is one less token in hyp, then the
		      # token in position $j has to be checked again
	    }
	}
	# after deletion of {[,],@} symbols, ref and hyp should have
	# the same number of tokens:
	if ($#ref != $#hyp) {
	    printf "ERROR: refN=%d != %d=hypN\n", $#ref, $#hyp;
	    exit(0);
	} else {
	    # debugging prints:
	    if ($verbose>1) {
		printf "ref|||hyp: ";
		    for ($l=0; $l<=$#ref; $l++) {
			printf "%s|||%s ", 
			encode("utf8",$ref[$l]), 
			encode("utf8",$hyp[$l]);
		}
		printf "\n";
	    }
	    # debugging prints:
	    if ($verbose>0) {
		printf "ref:  ";
		for ($l=0; $l<=$#ref; $l++) {
		    printf "%s ", encode("utf8",$ref[$l]);
		}
		printf "\nhyp:  ";
		for ($l=0; $l<=$#hyp; $l++) {
		    printf "%s ", encode("utf8",$hyp[$l]);
		}
		printf "\n";
	    }

	    # count mis/matches on tags:
	    for ($j=0; $j<=$#ref; $j++) {
		$tagRefN++ if &isTag($ref[$j]);
		if (!($ref[$j] cmp $hyp[$j])) { # tokens are equal
		    $corr++ if (&isTag($ref[$j]));
		    printf "%s|||%s (match: corr or shift)\n", 
		    encode("utf8",$ref[$j]), 
		    encode("utf8",$hyp[$j]) 
			if (&isTag($ref[$j])) && ($verbose>0);
		} else { # tokens are different
		    if (&isTag($ref[$j]) && &isTag($hyp[$j])) {
			$sub++;
		    } elsif (&isTag($ref[$j])) {
			$del++;
		    } elsif (&isTag($hyp[$j])) {
			$ins++ 
		    }
		    if ($verbose>0) {
			printf "%s|||%s ", 
			encode("utf8",$ref[$j]), 
			encode("utf8",$hyp[$j]) 
			    if (&isTag($ref[$j]) || &isTag($hyp[$j]));

			if (&isTag($ref[$j]) && &isTag($hyp[$j])) {
			    printf "(sub)\n", 
			} elsif (&isTag($ref[$j])) {
			    printf "(del)\n";
			} elsif (&isTag($hyp[$j])) {
			    printf "(ins)\n";
			}
		    } # closing: "($verbose>0)"
		} # closing: "tokens are different"
	    } # closing: "for ($j=0; $j<=$#ref; $j++)"
	} # closing: "else" of "if ($#ref != $#hyp)"
    } # closing: "($in[$i]=~/TER Score:/)"
} # closing: "for ($i=0; $i<=$#in; $i++)"

# print values for last segment:
if ($tagRefN>0) {
    printf "Sentence %9s: tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %5.2f\n",
    $sentId, $tagRefN, $corr, $sub, $del, $ins, $shift, "%", 100*(1-($corr-$ins)/$tagRefN);
} else {
    printf "Sentence %9s: tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %5.2f\n",
    $sentId,  0, 0, 0, 0, 0, 0, "%", 0;
}

# update global counts with the values of the last segment:
$TOTtagRefN+=$tagRefN; 
$TOTcorr+=$corr; 
$TOTsub+=$sub; 
$TOTdel+=$del; 
$TOTins+=$ins; 
$TOTshift+=$shift;

if ($TOTtagRefN>0) {
    printf "Total:%13s tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %5.2f\n", "", $TOTtagRefN, $TOTcorr, $TOTsub, $TOTdel, $TOTins, $TOTshift, "%", 100*(1-($TOTcorr-$TOTins)/$TOTtagRefN);
    printf "%.5f\n", (1-($TOTcorr-$TOTins)/$TOTtagRefN);
} else {
    printf "Total:%13s tagRefN=%03d corr=%03d sub=%03d del=%03d ins=%03d shft=%03d %serrorRate= %5.2f\n",    "",  0, 0, 0, 0, 0, 0, "%", 0;
    printf "0\n";
}

exit(0);

sub isTag () {
    local($token)=@_;
    return ($token=~/^<.*>$/);
}
